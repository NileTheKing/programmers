import java.util.*;

// 상태 관리를 위한 State 클래스 (int[] 대신 사용)
class State {
    int rr, rc, br, bc, turn;
    boolean[][] redVisited;
    boolean[][] blueVisited;

    public State(int rr, int rc, int br, int bc, int turn, boolean[][] redVisited, boolean[][] blueVisited) {
        this.rr = rr; this.rc = rc;
        this.br = br; this.bc = bc;
        this.turn = turn;
        this.redVisited = redVisited;
        this.blueVisited = blueVisited;
    }
}

class Solution {
    int m, n;
    int[][] maze;
    int[][] directions = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    
    public int solution(int[][] maze) {
        this.maze = maze;
        m = maze.length;
        n = maze[0].length;

        int[] redStart = new int[2], blueStart = new int[2];
        int[] redEnd = new int[2], blueEnd = new int[2];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (maze[i][j] == 1) redStart = new int[]{i, j};
                if (maze[i][j] == 2) blueStart = new int[]{i, j};
                if (maze[i][j] == 3) redEnd = new int[]{i, j};
                if (maze[i][j] == 4) blueEnd = new int[]{i, j};
            }
        }

        Queue<State> q = new LinkedList<>();
        boolean[][][][] visited = new boolean[m][n][m][n];

        boolean[][] initialRedVisited = new boolean[m][n];
        boolean[][] initialBlueVisited = new boolean[m][n];
        initialRedVisited[redStart[0]][redStart[1]] = true;
        initialBlueVisited[blueStart[0]][blueStart[1]] = true;

        q.offer(new State(redStart[0], redStart[1], blueStart[0], blueStart[1], 0, initialRedVisited, initialBlueVisited));
        visited[redStart[0]][redStart[1]][blueStart[0]][blueStart[1]] = true;

        while (!q.isEmpty()) {
            State current = q.poll();
            int rr = current.rr, rc = current.rc;
            int br = current.br, bc = current.bc;
            int turn = current.turn;
            
            boolean isRedArrived = (rr == redEnd[0] && rc == redEnd[1]);
            boolean isBlueArrived = (br == blueEnd[0] && bc == blueEnd[1]);

            if (isRedArrived && isBlueArrived) return turn;

            // 경우 1: 둘 다 아직 도착하지 않음
            if (!isRedArrived && !isBlueArrived) {
                for (int[] d1 : directions) {
                    for (int[] d2 : directions) {
                        int nrr = rr + d1[0], nrc = rc + d1[1];
                        int nbr = br + d2[0], nbc = bc + d2[1];
                        
                        // --- 유효성 검사 (하드코딩) ---
                        if (nrr<0 || nrc<0 || nrr>=m || nrc>=n || maze[nrr][nrc]==5) continue;
                        if (nbr<0 || nbc<0 || nbr>=m || nbc>=n || maze[nbr][nbc]==5) continue;
                        if (current.redVisited[nrr][nrc] || current.blueVisited[nbr][nbc]) continue;
                        if (visited[nrr][nrc][nbr][nbc]) continue;
                        if (nrr == nbr && nrc == nbc) continue;
                        if (nrr == br && nrc == bc && nbr == rr && nbc == rc) continue;
                        
                        // --- 큐에 추가 (하드코딩) ---
                        boolean[][] nextRedVisited = deepCopy(current.redVisited);
                        boolean[][] nextBlueVisited = deepCopy(current.blueVisited);
                        nextRedVisited[nrr][nrc] = true;
                        nextBlueVisited[nbr][nbc] = true;
                        visited[nrr][nrc][nbr][nbc] = true;
                        q.offer(new State(nrr, nrc, nbr, nbc, turn + 1, nextRedVisited, nextBlueVisited));
                    }
                }
            } 
            // 경우 2: 빨강만 도착
            else if (isRedArrived && !isBlueArrived) {
                for (int[] d2 : directions) {
                    int nrr = rr, nrc = rc; // 빨강은 제자리
                    int nbr = br + d2[0], nbc = bc + d2[1];

                    // --- 유효성 검사 ---
                    if (nbr<0 || nbc<0 || nbr>=m || nbc>=n || maze[nbr][nbc]==5) continue;
                    if (current.blueVisited[nbr][nbc]) continue;
                    if (visited[nrr][nrc][nbr][nbc]) continue;
                    if (nrr == nbr && nrc == nbc) continue;
                    
                    // --- 큐에 추가 ---
                    boolean[][] nextRedVisited = deepCopy(current.redVisited);
                    boolean[][] nextBlueVisited = deepCopy(current.blueVisited);
                    nextBlueVisited[nbr][nbc] = true;
                    visited[nrr][nrc][nbr][nbc] = true;
                    q.offer(new State(nrr, nrc, nbr, nbc, turn + 1, nextRedVisited, nextBlueVisited));
                }
            }
            // 경우 3: 파랑만 도착
            else if (!isRedArrived && isBlueArrived) {
                for (int[] d1 : directions) {
                    int nrr = rr + d1[0], nrc = rc + d1[1];
                    int nbr = br, nbc = bc; // 파랑은 제자리
                    
                    // --- 유효성 검사 ---
                    if (nrr<0 || nrc<0 || nrr>=m || nrc>=n || maze[nrr][nrc]==5) continue;
                    if (current.redVisited[nrr][nrc]) continue;
                    if (visited[nrr][nrc][nbr][nbc]) continue;
                    if (nrr == nbr && nrc == nbc) continue;
                    
                    // --- 큐에 추가 ---
                    boolean[][] nextRedVisited = deepCopy(current.redVisited);
                    boolean[][] nextBlueVisited = deepCopy(current.blueVisited);
                    nextRedVisited[nrr][nrc] = true;
                    visited[nrr][nrc][nbr][nbc] = true;
                    q.offer(new State(nrr, nrc, nbr, nbc, turn + 1, nextRedVisited, nextBlueVisited));
                }
            }
        }
        
        return 0;
    }

    // 2차원 배열 깊은 복사 (이 함수는 여전히 필요합니다)
    private boolean[][] deepCopy(boolean[][] original) {
        boolean[][] copy = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            copy[i] = Arrays.copyOf(original[i], n);
        }
        return copy;
    }
}
